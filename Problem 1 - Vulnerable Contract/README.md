# Smart Contract Audit

To audit the provided contract, a mix of software tooling and traditional testing methods were utilized. Firstly, Slither was used to statically scan for vulnerabilities. Then, some custom fuzz and invariant tests were written to capture any edge cases.

Some thinking on why Slither was utilized, Slither is blazing fast compared to other scanning tools due to the fact that it builds an abstract syntax tree instead of decompilation to bytecode and running analysis at opcode level. This comes at a cost of not being able to discover as many low level vulnerabilities as MythX and gives more false positives. Given that this is a rather simple contract and the process involves a human audit, Slither is still preferred for the speed.

## Static scanning with Slither
After running the provided code through slither, and having the result returned through a nice interface provided by AuditWizard, the following vulnerabilities were discovered.

[Insert screenshots here]

#### Analysis of discovered vulnerabilities

##### High priority - Reentrancy
Reentrancy is a state synchronization vulnerability. The attacking contract is able to bypass balance checks on the vulnerable contract because the balance state has not yet being updated. This allows the attacking contract to repeatedly call the withdraw function on the vulnerable contract until the contract is drained. The attack generally follows this pattern:

1. Attacking contract deposits a small amount into the vulnerable to bypass the initial check on the withdraw function.
1. Attacking contract calls withdraw.
1. Vulnerable contract makes a transfer.
1. The fallback function of the attacking contract makes a reentrant call back int othe withdraw function of the vulnerable contract.
1. Since the balance has not yet been updated, vulnerable contract keeps sending eth to the attacking contract until it is drained.

There are multiple ways to prevent reentrancy attacks such as Openzeppelin's reentrancy guard modifiers, using the pullpayment workflowor making your contract pausable but from a Solidity development point of view, the Check-Effect-Implement is regarded as the coding pattern to follow. Fix below:

```
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance"); // Check - require sufficient balance
    balances[msg.sender] -= amount; // Effect - balance reduced
    (bool success, ) = msg.sender.call{value: amount}(""); //Interaction - send funds via call
    require(success, "Transfer failed");
}
```

##### Missing address zero check - Medium priority
When setting a new owner in the *transferOwnership* function, there is no guard against the current owner setting the new owner to an unreachable address such as the null address. This would essentially disable all functions which has the onlyOwner modifier. Given that only the *transferOwnership* function has this modifier, the general functionality of the contract would be preserved. Therefore, a medium classification is given despite it classified as low by the scanner. The propose fix is:

```
function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0), "Null address cannot be an owner");
    address oldOwner = owner;
    owner = newOwner;
```

##### Missing event on critical control flow - Low priority
Events are emitted for easy indexing and auditing. The contract does not emit an event upon ownership transfer, therefore rendering it impossible to track ownership history. While this does not result in the loss of funds, and is therefore low priority, it increases the difficulty of backtracing. The suggested fix is to implement a TransferOwnership event.

```
event TransferOwnership(address indexed oldOwner, address indexed newOwner);

function transferOwnership(address newOwner) public onlyOwner {
    address oldOwner = owner;
    owner = newOwner;
    emit TransferOwnership(oldOwner, newOwner);
}
```